Excellent rÃ©flexe âœ…
Oui, tu peux appeler directement ta route /reset-demo-app depuis la route /disconnect, plutÃ´t que de rÃ©Ã©crire la logique Kubernetes Ã  lâ€™intÃ©rieur.
Câ€™est plus propre, plus court et surtout plus maintenable.


---

âš™ï¸ Voici les seules lignes Ã  ajouter

Dans ta fonction /disconnect,
juste aprÃ¨s :

app.logger.info(f"[logout] {username} dÃ©connectÃ© manuellement ")

â¡ï¸ ajoute :

# ğŸ” Appelle directement la route /reset-demo-app pour ce user
try:
    requests.post("http://localhost:5000/reset-demo-app", json={"user": username})
    app.logger.info(f"[logout] Demo-app de {username} rÃ©initialisÃ©e via /reset-demo-app")
except Exception as e:
    app.logger.warning(f"[logout] Ã‰chec de l'appel /reset-demo-app pour {username}: {e}")

Et pareil pour la fermeture sauvage :
aprÃ¨s :

r.set(f"user:{username}:closed_at", ts)
app.logger.info(f"[disconnect] ClÃ©s Redis supprimÃ©es pour {username} (fermeture sauvage t)closed_at={ts}")

â¡ï¸ ajoute :

# ğŸ§¹ RÃ©initialisation auto de la demo-app aprÃ¨s fermeture sauvage
try:
    requests.post("http://localhost:5000/reset-demo-app", json={"user": username})
    app.logger.info(f"[disconnect] Demo-app de {username} rÃ©initialisÃ©e via /reset-demo-app (fermeture sauvage)")
except Exception as e:
    app.logger.warning(f"[disconnect] Ã‰chec de l'appel /reset-demo-app (fermeture sauvage) pour {username}: {e}")


---

ğŸ§© Nâ€™oublie pas

Il faut importer requests en haut du fichier si ce nâ€™est pas dÃ©jÃ  fait :

import requests


---

ğŸ’¡ Avantage :

plus simple (une seule source de vÃ©ritÃ© dans /reset-demo-app)

et Flask sâ€™appelle lui-mÃªme proprement en local (localhost:5000 fonctionne dans le mÃªme pod).


Souhaites-tu que je tâ€™indique comment faire si ton dashboard est dans un autre conteneur (pour adapter lâ€™URL interne du requests.post au service Kubernetes) ?

